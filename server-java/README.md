## 프로젝트

## 📚 문서

- [마일스톤](./docs/milestone/MILESTONE.md) - 프로젝트 개발 일정 및 단계별 계획
- [ERD](./docs/erd/ERD.md) - 데이터베이스 설계 및 테이블 구조
- [시퀀스 다이어그램](./docs/sequence/README.md) - 비즈니스 플로우 및 API 흐름
- [API 명세](./docs/api-spec/openai.yaml) - OpenAPI 스펙
- [인프라 구성](./docs/infra/infrastructure.md) - 인프라 아키텍처 및 배포 전략

## Getting Started

### Prerequisites

#### Running Docker Containers

`local` profile 로 실행하기 위하여 인프라가 설정되어 있는 Docker 컨테이너를 실행해주셔야 합니다.

```bash
docker-compose up -d
```

# e-commerce prj

## 아키텍처 

### 기능적 요구사항
- 상품조회 api
- 주문생성
- 결제실행
- 포인트 조회 / 충전

### 비기능적 요구사항

- 성능
  - tps 100을 목표로 진행합니다. 
- 확장성
  - interface 및 분산서버 대응하여 확장
- 가용성
  - 서비스가 중단 되지 않도록 
- 보안 
- 유지보수성
  - DDD로 인한 유지보수성을 관리합니다.  

### 요구사항 명세서 
- 필수
 - [ ] 상품조회 API  
 - [ ] 주문생성 API
 - [ ] 결제실행 API
 - [ ] 포인트조회 API
 - [ ] 포인트충전 API

- 추가기능
 - [ ] 결제조회 API
 - [ ] 환불실행 API
 - [ ] 유저 로그인 API
 - [ ] 유저생성 API

- 심화(선택) 

 - [ ] 쿠폰생성 API
 - [ ] 쿠폰조회 API
 - [ ] 인기상품조회 API

### 요구 사항 분석

`상품조회`
기능: 상품을 조회한다.
조건
1. 상품을 조회하기 위해 , 상품생성이 필요하다.
2. 이름, 가격 , 상태 , 생성일 , 수량을 갖는다.
3. 수량에 대한 동시성 처리가 가능 해야한다.

`주문조회`
기능: 주문을 생성한다.
조건:
1. 주문은 상품와 관계가 존재한다.
2. 주문은 주문리스트를 갖는다.
3. 생성한 주문을 조회 할 수 있어야 한다.

`결제조회`
기능: 결제를 실행한다.
조건:
1. 결제는 주문와 관계가 존재한다.
2. 결제는 여러가지 다른 관계가 올수도 있다.
3. 결제조회가 가능해야한다.
4. 결제취소가 가능해야한다.

`포인트조회`
기능: 포인트을 조회한다.
조건:
1. 포인트는 유저와 1:1 관계를 갖는다.
2. 특정 유저의 포인트를 조회한다.

`포인트생성`
기능: 포인트을 생성한다.
조건:
1. 포인트는 유저와 1:1 관계를 갖는다.
2. 생성한 포인트가 특정 유저에 포인트 금액 관리가 되어야한다.


요구사항 분석을 통해 추가해야할 API

- 결제조회 API
- 환불실행 API
- 유저 로그인 API
- 유저생성 API
- 유저생성 API
- 유저생성 API


`쿠폰생성`
기능: 쿠폰을 생성한다.
조건
1. 쿠폰은 유저와 관계를 갖는다.
2. 선착순 쿠폰. 등 특별한 상태 일 수있다.
3. 만약에 쿠폰의 적용이 상품별로 다를 수있다면, 상품과도 관계를 갖는다. 그리고 별도의 도메인이다.

`쿠폰조회`
기능: 쿠폰을 조회한다.
조건
1. 쿠폰 수량에 대한 동시성 처리가 가능해야한다.
2. 선착순 쿠폰이면, 여러 유저의 동시성 접근에 대한 처리가 가능해야한다.

`인기상품조회`
기능: 인기상품을 조회한다.
조건
1. 인기 상품 조회 한다.
2. 인기 상품에 대한 조건을 설계한다.
3. 인기 상품은 주문수량, 결제진행 상황, 등을 고려해 요일별 , 주별 다양한 조건이 설정 될수 있다.
4. 인기 상품은 배치가 돌수도 있다.

---

## ADR (Architecture Decision Record) = 아키텍처 의사결정 기록

- [ ] ADR-001 : DDD 레이어 구조 - 왜 DDD?
- [ ] ADR-002 : 왜 ? 모놀리식
- [ ] ADR-003 : 왜 인터페이스 기반 설계 하였고, 왜 추상화를 고려하였는가 ?  

- [ ] ADR-004 : Order Aggregate 경계 - OrderItem 포함이유
- [ ] ADR-005 : 금액 계산 책임 - Order vs Payment
- [ ] ADR-006 : 쿠폰의 별도 도메인 이유
- [ ] ADR-007 : 포인트 테이블 분리
- [ ] ADR-008 : 수량이 Product의 속성으로 종속된 이유  
- [ ] ADR-009 : 환불도메인 생성이유


- [ ] ADR-011 : 식별자 선택이유 (UUID vs Long)
- [ ] ADR-012 : 히스토리 테이블 vs 컬럼 스냅샷 - 언제 써야할까 ?   
- [ ] ADR-013 : 직접 참조 vs 간접 참조(ID 참조)- 언제 어떻게 써야할까 ? 
- [ ] ADR-014 : 인덱스 전략
- [ ] ADR-015 : payment 테이블 전략

- [ ] ADR-016 : 트랜잭션 경게
- [ ] ADR-017 : 격리 수준 선정 이유

- [ ] ADR-018 : 재고 동시성 - 비관적 락 vs 낙관적 락
- [ ] ADR-019 : 쿠폰 선착순 Redis INCR vs Redis sortedSet
- [ ] ADR-020 : 포인트 동시성 제어 필요성
- [ ] ADR-021 : 데드락 방지  



ADR-001 : DDD 레이어 구조 - 왜 DDD?
- Domain 객체의 책임과 역할에 대해서 공부 해보며 , 연습을 위해서
- 누가 보든 한번에 이해하기 쉽게 하기 위함인데 , 여기엔 AI도 포함

ADR-002 : 왜 ? 모놀리식
- 초기 모델은 DB가 단일 구조로 개발
- 단일 구조 , DB의 엔티티의 직접참조(pk,fk) 기반이기 때문에

ADR-003 : 왜 인터페이스 기반 설계 하였고, 왜 추상화를 고려하였는가 ?
- 인터페이스를 사용해서 , 확장 가능한 코드베이스 설계하기 위해서
- 인터페이스 구조를 통해 다향성 적용하고, 역할을 분리 하기 위해


ADR-004 : Order Aggregate 경계 - OrderItem 포함이유
- Order와 OrderItem은 같은 생명주기를 가지기 때문에
- 만약 분산환경으로 가더라도 생명주기는 같기 때문에

ADR-005 : 금액 계산 책임 - Order vs Payment
- 저는 Order가 금액의 책임이 있다고 결정
  - Order에 여러 OrderItem이 존재하고 이에 대한 어떤 정책이 존재할 수 있으므로
  - ASIS - 주문에 쿠폰 등등 , TOBE - 주문아이템별 쿠폰, 특정 프로모션 등등
- Payment가 금액 계산에 대한 책임이 존재한다면, 금액이 맞지 않을때, 주문에 역할이 모호해짐으로 Payment는 금액계산의 책임이 없고 , Order의 금액계산을 믿어야할것으로 판단
 

ADR-006 : 쿠폰의 별도 도메인 이유
- 쿠폰은 다양한 비즈니스 로직이 존재하여, 별도의 도메인으로 생각
- 특정 상품(주문아이템) 쿠폰, 주문전체 적용 쿠폰 다양한 비즈니스가 존재할것으로 예상되어
- 선착순 쿠폰 요구사항으로 인한, 독립적인 쿠폰 필요성 존재 

ADR-007 : 포인트 도메인
- 포인트를 유저에 종속할지 독립적으로 존재할지 고민
  - 포인트가 충전 및 사용 비즈니스 요구사항을 보고 현금성 포인트로 결정
- 유저에 포인트가 종속되는 느낌이 존재하지만, 현금성 포인트라면, 이력 및 만료기간이 존재할것으로 생각 별도의 도메인으로 존재해야함으로 생각


ADR-008 : 재고가 Product의 속성으로 종속된 이유
- 현재 비즈니스 요구사항에서는 product만 재고가 필요하여 , product에 포함
- 추후 다양한 재고관리가 생기고 , 기간별 재고가 다를수있다면, 별도의 재고 도메인으로 추출할것!

ADR-009 : 환불도메인 생성이유
- 결제 요구사항이 존재하였고, 결제가 된다면 환불도 되어야함으로


ADR-011 : 식별자 선택이유 (UUID vs Long)
- Long형 사용시 특정 테이블의 패턴이 보여 전체 수량 추적가능성이 존재
- UUID를 중복될 가능성이 매우 낮음 (증명된 확률)
- 마이그레이션시 숫자에 종속될 필요가 없다고 생각함

ADR-012 : 히스토리 테이블 vs 컬럼 스냅샷 - 언제 써야할까 ?
- XXXHistroy table이 존재한다면, 특정 테이블의 이력 확인가능 
  - 추후 상품의 데이터 변경이 존재하면 추적 가능
  - but 복잡한 비즈니스 (join가능성, 주문별 조회를  더해야함 ) 
- 컬럼 스냅샷이 존재한다면, 확정당시(주문생성, 결제실행)등에 대한 확정된 데이터 보유
  - 이는 비정규화로 , 추후 해당 주문의 상품 삭제 , 금액 변경 등이 발생해도, 최초 데이터 보유하기 때문에 DB를 더 조회할 필요 없음
- 비즈니스적인 상황 이력을 확실하게 관리하고 이에 대한 비즈니스가 필요하면, table
- 변경가능성이 적고 , 컬럼단에서 조절가능 하다면 컬럼 스냅샷

ADR-013 : 직접 참조 vs 간접 참조(ID 참조)- 언제 어떻게 써야할까 ?
- 직접 참조(물리적 참조) : fk등으로 제약조건을 걸어 데이터의 삭제에 안정적인 정책
- 간접 참조(논리적 참조) : fk등을 제약조건으로 걸지 않고 단지 컬럼 데이터 ( 유니크한 데이터 Ex-ID)등으로 참조는 거는상황
- 생명주기가 같다면 직접 참조 (단일 DB 환경) , 테이블간 어떤 관계가 존재하지만, 삭제되어도 서로 상관없는 관계라면 간접 참조( 분산 환경 )

ADR-014 : 인덱스 전략
- 식별자에는 대부분 인덱스 생성
- 검색 조건에 해당하는게 있다면 인덱스 생성 (createAt , status 인덱스 생성)

ADR-015 : payment 테이블 전략
- 결제는 결제이력이 필요
  - 결제는 레코드를 append하는 방법 , update하는 방법 두가지 존재 
- append 이점 
  - 이력이 자동으로 남아 추적 용이 
  - insert 충돌이 적음 ( 락 경합 감소 )
  - 추가 결제 비즈니스가 자연스러움 ( 부분결제 , 부분환불)
- append 단점 
  - 최종 상태 조회시 집계 필요 
  - 비즈니스 로직 복잡
  - 인덱스 설계 중요 (order_id, create_at)
- update 이점 
  - 최종 상태 조회 간단 및 가시성 좋음
- update 단점 
  - 이력 사라짐 
  - update 락 경합 존재 
  - 이력이 없으므로 추가 결제 비즈니스 부분결제, 부분환불시 이력 필요 및 비즈니스 복잡
- 두방법 모루 동시성 관리는 필요


ADR-016 : 트랜잭션 경게
- 비즈니스(service) 단위 원자성 보장
  - 주문 생성 = 재고 차감 + 주문 저장 + 쿠폰 차감
- controller 트랜잭션 없음
  - 트랜잭션 존재하여, http 커넥션 점유 시간 증가 
- Repository 트랜잭션 없음
  - 상위 레이어 Service에서 진행하므로 XXRepository에서 동일 트랜잭션으로 묶임
- 트랜잭션은 spring의 @Transaction로 진행 
  - @Transaction은 spring의 proxy객체를 새로 생성 
  - 프록시 객체가 생성되면 aop기능을 통해 해당 애노테이션이 존재하는 메서드에 db 트랜잭션을 설정
  - spring에서 트랜잭션은 self-invocation 안되니 주의


ADR-017 : 격리 수준 선정 이유
- READ_COMMITED
  - Dirty Read 방지 : 커밋된 데이터만 읽음
  - Non-Repeatable Read 가능 : 같은 트랙잯션 내에서 같은 데이터를 다시 읽으면 값이 달라질 수 있음 
  - Phantom Read 가능 : 같은 조건으로 조회시 결과 행 수가 달라질 수 있음
- Non-Repeatable Read 하므로 Lock 설정 필수 (비관적락)
- REPEATABLE_READ
  - 트랜잭션 내에 일관된 데이터가 필요하면 설정
- 격리 수준은 mysql default 설정
- READ_COMMITED 설정 이유 : 성능과 동시성 균형
- SERIALIZABLE 성능저하 (성능이 느리더라고 확실할때 사용)


ADR-018 : 재고 동시성 - 비관적 락 vs 낙관적 락
- 비관적락: 특정 부분은 동시 접근시 해당 부분 잠금
  - 만약 경합이 발생하면 대기하는 방법의 락
  - 조회시 락 
- 낙관적락: 특정 부분에 동시 접근시 , version을 통해서 확인
  - 만약 버전이 다르면 충돌 -> 재시도 로직 필요
  - 수정시 버전을 확인하해서 실패를 일으킴으로 락이 없음 (표현을 락이라고 표현)
- 재고는 조회시점에서 락 필요 -> 비관적락 적합
  - 단점 
    - 성능이 상대적으로 딸림
    - 데드락 발생 가능성 존재 
- 재고는 충돌 빈도가 높아 낙관적 락 사용시 재시도 반복 

ADR-019 : 쿠폰 선착순 발급 기능 
- 쿠폰 선착순 발급 기능은 순차적 접근이 필요 
- 프로그래밍 단에서 동시성 제어
  - syncronized를 이용한 동시성제어 -> 단일서버사용 가능 
- DB 단에서 비관적 , 낙관적 잠금
  - 비관적 잠금 : 쿠폰 조회시 락을 걸고 트랜잭션을 통해 일관성 보장
  - 낙관적 잠금 : 충돌이 높아 재시도가 빈번하게 발생
  - 두가지 방법 모두 락 경합으로 대기 시간 발생
  - DB I/O로 인한 성능저하 , 동시 처리량 낮음
- Redis INCR
  - 원자적 연산 지원하는 redis 연산 , 분산서버 사용가능 
- 다양한 방법중 가장빠르고 , 분산서버를 지원하는 INCR로 선택

ADR-020 : 포인트 동시성 제어 필요성
- 포인트는 유저랑 1:1 관계
- 사용 동시 요청시 동시성 문제 발생
- 성능을 고려해서 설계 
  - 비관적락 , 낙관적락 

ADR-021 : 데드락 방지
- 두 프로세스에서 서로 락을걸어서 다음으로 넘어가지 못하는 상황
- 주문1의 주문아이템 A,B 와 주문2의 주문아이템 B,A가 존재할때, 
  - 주문1,2가 서로 A,B의 락을 걸면 주문 1의 B와 주문 2의 A에 접근이 안되어 대기
  - 이런상황을 데드락으로 표현
- 락 순서 일관성 보장 , 락 타임아웃  , 단일행 락 수행 이 존재
- 비관적 락을 걸 때, 트랜잭션에서 동일한 락 순서를 보장
- 락 타임아웃: 락에 걸리면 타임아웃을 둠 
  - 임시해결
  - 재시도 필요 
- 단일락 수행 : 비즈니스의 원자성 미보장
  - 원자성 미보장 및 롤백처리 복잡
- 트랜잭션안에서 정렬시(락순서) 데드락 차단 , 간단한구현 가능  

ADR-022 : Redis 선택이유 
- 쿠폰 선착순 기능을 위한 redis 선택
- 성능을 위해서 캐시를 두려고 하는데, 확장성을 고려한 분산캐시
- redis 원자적 연산 지원 , 싱글스레드 , 인메모리데이터 베이스 
- 로컬캐시보다 레디스를 선택한 이유는 확장성을 고려하였기 때문


## 비기능적 요구사항

### 성능

**AS IS**
- tps 1000을 목표로 진행
- cache를 사용

**TO BE**
- tps 10000을 목표로 진행
- cache를 사용 -> 클러스터 
- DB replica 사용
  - 읽기전용 & 쓰기전용
- 비동기 통신 (message queue)
- 분산서버 

### 확장성

**AS IS**
- 변동가능한 함수는 interface ( jpa , XXXService)
- DB는 단일 디비 ( 직접 접근 )

**TO BE**
- DB는 분산 디비 ( 간접 접근 )
- 비동기 api 통신 및 message queue
- api 이외의 다양한 통신 지원 ( grpc ) 

### 가용성

**AS IS**
- 도커 및 수동 배포

**TO BE**
- kubernetes를 통해 배포
  - rolling update 지원
- 서버 클러스터링 ( 레디스 , RDB , API Server)
- cloud 서비스 사용 
  - 다중 클라우드 ( 이중화 )
  - 클라우드 서버 디비 백업  

### 보안

**AS IS**
- 개인정보 필드 암호화

**TO BE**
- TLS(https) 설정
- 로그인시 인증 인가 체계

### 유지보수성

**AS IS**
- DDD를 통해 역할과 책임 분리
- docs를 통한 문서화 
- 테스트 코드

**TO BE**
- 다양한 기능이 존재하는 서버는 별도의 프로젝트로 분리 



